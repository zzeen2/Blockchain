# EVM에서 실행할수 있는 솔리디티 컨트랙트

## contract
> 작성하는 코드를 바이트 코드로 변환해서 네트워크에 기록
> EVM의 스토리지에 영구적으로 저장되고 블록에 기록된다.

### EOA
> 계정 사용자가 있는 계정
> 트랜잭션을 발생시키기 위해서 사용한다.

## contract로 만든 계정 CA
> 컨트랙트 계정 
> 배포된 컨트랙트는 블록에 기록되고 코드의 내용은 EVM에서 저장하고 사용한다.

### 솔리디티
> 이더리움 블록체인에서 스마트 컨트랙트를 작성하기 위해서 만들어진 상위 프로그래밍 언어
> 계약서를 작성할수 있는 프로그램
> 비트코인은 복잡한 계약을 작성할수 없었다.
> 2013년 비탈릭 부테린이 이더리움 백서를 작성
> 2015년 이더리움 메인넷 출시
> 이더리움 네트워크에서 블록체인 위에 조건을 가진 계약을 작성할수 있게 제공되었다.
> 계약서를 작성할수 있도록 제공해주는 도구가 솔리디티

#### 솔리디티 장점
> (우리한테 장점)javascript와 비슷한 문법을 가지고 있다.
> 이더리움 네트워크의 가상 머신 EVM에서 실행이 가능한 바이트 코드를 컴파일할수 있다.
> 스마트 컨트렉트를 작성할때 가장 많이 사용하는 언어.

#### 스마트 컨트렉트 계약
> 조건이 충족되면 자동으로 실행되는 코드의 내용을 작성
> 절차지향 코드를 작성하면 된다.
> 중앙기관이 없이 실행된다 => 이더리움 네트워크에 EVM에서 실행을 하고 상태변수로 저장 블록에 기록

#### 솔리디티 문법

```js
class Counter {
    value : number; // 이게 상태변수
    constructor() {}
    setValue() {} // 상태변수 전환 함수 트랜잭션 발생시
    getValue() {} // 조회 메시지 발생
}
// 컨트랙트 배포
const _0x123 = new Counter(); // 첫 번째 주소 CA
const _0x124 = new Counter(); // 두 번째 주소 CA
// 컨트랙트 주소를 받아서
// CA로 => 요청 (setValue를 호출해줘)
// RPC 통신 원격 프로시저 호출 => 응답을 받는게 목적이 아니고
// 단순한 데이터를 다루고 프로세스 즉 EVM에서 실행시켜줘라. 
_0x123.setValue()
// 첫번째 두번째는 둘다 서로 다른 주소를 가지고 있다.
```
> 솔리디티의 문법은 자바스크립트의 클래스 문법과 많이 유사하다.
> // SPDX-Lisence-identifier : MIT 코드 작성할때 첫줄에 포함되어야한다.
> 주석도 읽어서 //SPDX-Lisence-identifier : MIT 이 구문을 읽는다
> 누구나 사용 가능한 라이센스
> 법적인 명확성. 코드가 어떤 조건 내에세 배포가 되었는지 표한할 수 있다.
> MIT 라이센스는 사용 복사 수정 병합 게시 배포 등등 모두 가능한 라이센스
> 오픈소스를 따라서 개발한다.
> 크립토 좀비
```js

// SPDX-License-identifier: MIT
pragma solidity 0.8.30;

contract Counter {
    uint Count = 0; // 상태변수 선언 int === number uint 양수로만 표현될 데이터
    
    // 컨트렉트 배포할때 딱 한번 => 배포가 되어서 CA가 생성될 떄 
    constructor(address_CA) {
        // 누군가에게 에어드랍 준다.
        count2= _CA
        setValue() // 컨트렉트 내부 호출

    }

    // 컨트랙트 내부의 함수는 function 예약어를 사용해서 함수 작성
    // 접근자
    // public 어디서든 호출할 수 있는 제한이 없는 함수 접근자
    // 외부호출 => 요청 즉 RPC 통신으로 받아서 원격 프로시저 호출을 한다.
    // 상속도 가능하고 주소만 가지고 사용도 가능하다.
    // 하나의 컨트렉트가 되는것이 상속
    // 주소를 알고있는것은 컨트렉느가 2개
    function setValue(uint _Count) public {
        Count = _Count;
    }

    // 조회만 가능한 함수 수정자 view
    function getValue() pulic view {
        return Count;
    }
}

// 전체 코드 내용을 컴파일해서
// ABI ByteCode
// EOA => ByteCode 네트워크에 트랜잭션 발생. 바이트 코드를 받으면 내용을 확인해서 컨트렉트 배포 함수를 호출한다.
// EVM 저장소 ByteCode 저장되고
// 블록에 기록되고 CA 생성된다. => CA 주소로 이후에 요청을 보낼때 CA를 포함시키고 호출할 메서드 이름을 포함시켜서 요청보내면 호출이된다. 
// ABI 메타데이터 
// 바이너리 코드를 사용할때 제공되는 인터페이스 
```

### 우리가 작성할수 있는 레벨의 언어로 표현하는것이 솔리디티 
1. 라이센스 정보
2. 솔리디티 버전
3. 컨트랙트 내용

> 자바스크립트 클래스는 인스턴스를 생성하는 과정이 new 키워드를 사용해서 만들었다.
> new 키워드를 통해서 생성된 인스턴스들은 다른 메모리 공간을 가지고 있게 된다. new로 생성된 모든 객체는 다른 주소를 가지고 있따.
> 컨트랙트는 객체를 하나 생성하고 모든 사용자 컨트랙트 사용자들은 하나의 인스턴스를 사용하는 방식으로 CA 주소를 모두 알고 요청을 보내서 사용하는것 => 싱글톤 패턴

### 배포 프로세스

1. 컨트랙트 코드 작성
2. 컨트랙트 코드 컴파일
3. 트랜잭션 메세지 생성(보내는 사람 가스비 가스당 가격, data 메세지 내용)
4. 개인키 서명 하면서 트랜잭션 발생
5. 트랜잭션이 블록이 생성되고 기록되어서 CA의 값을 받을 수 있고 받은 CA에는 codehash에 바이너리 코드
6. CA를 가지고 트랜잭션을 보낼때 메세지로 ABI의 내용을 바이트코드로 변환해서 요청보내면 해당 메서드를 호출한다.
7. 블록이 생성되고 트랜잭션 처리가 끝나면 EVM이 실행 결과를 상태변수에 빈영 이 내용도 블록에 기록되어 있다.

### 메타마스크
> 테스트 이더
> 개인키 서명 => 서명 생성해서 트랜잭션에 포함 ( 우리가 수동으로 해도 되지만 )
> 개인키 서명을 만들어서 트랜잭션에 포함 => 지금 사용하는 컴퓨터 로컬에 개인키가 저장이 되어있다.
> 마스터키 지갑안에 계정을 여러개 만들 수 있다. 암호화된 시드를 저장해서 보관하고 있다가 
> 이 시드를 가지고 마스터키를 복원할 수 있다.
> 비밀 백업 구문 => 니모닉

### 니모닉
> 니모닉은 BIP-39(비트코인 제안서 커뮤니티에서) 표준에 따른 사람이 읽기 쉬운 방식의 시드 형태 문구 
> 12,15,18,24 등 단어의 조합을 가지고 있다 
> 무작위 바이트를 사람이 읽기 쉬운 영어 단어로 바꾼것.
> 니모닉 -> 마스터키 -> 개인키 공개키를 만드는 구조(개인키중에 하나가 공개되어도 마스터키 역산은 불가능)
> 지갑에 접속할때 포함시킨 비밀번호 + 니모닉으로 시드를 만든다.

> 0x4CAe468eAC67b79fBD311c840F38bD134b0ceF28 이런 공개키에 이더 송금을 하면 자산이 입금

### 네트워크 통신
> 노드를 운영하지 않고
> 큰 기업들이 제공하는 이더리움 제단 등 바이낸스
> RPC 엔드포인트를 받아서 공급자 역할을 해서 우리한테 노드 이용을 할 수 있게 도와주겠다.
> 우리가 서명을 만들어서 보내서 그 메세지를 노드 이용을 해주는 것
> 공급자

### web3 라이브러리
> 이더리움 네트워크랑 상호작용을 할 수 있도록 도와주는 공급자 역할
> 브라우저 혹은 nodejs 환경에서 네트워크와 통신을 도와준다.

### 카운트 구현
1. html 구현 계정 UI

2. 카운트 호출 (컨트렉트 작성 후 컴파일 ABI byteCode)
- solc 라이브러리 사용
```sh
npm i -g solc;

## 옵션들
npx solc --bin --abi 파일경로 -o 내보낼경로

```
