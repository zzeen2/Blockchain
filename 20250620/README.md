# 이더리움 네트워크

> 이더리움을 만든 사람은 비탈릭 부테린 비트코인을 옹호하는 느낌을 많이 받았다. 
> 기술적인 부분은 비트코인 백서에서 이미 알고 있다. 이더리움 백서에서는 비트코인의 확장된 내용을 많이 서술한다.
> 비탈릭 부테린이 게임을 좋아했는데, 
> 이더리움 네트워크를 만들 때 생각이 본인이 키우던 게임 캐릭터랑 아이템이 한순간 사라지면서 아쉬움을 느꼈다. 

> 비트코인은 화폐를 집중해서 만든 네트워크, 이더리움의 네트워크는 단순하게 화폐만이 아닌 플렛폼 개발을 목적으로 만들었다. (컨트렉트 개발이 가능한 이유) ( 이더리움 코인 돈처럼 쓰는데) 이더리움 네트워크는 화폐를 기준으로 만든 네트워크가 아니다. 

> 비트코인의 한계를 보안하기 위해서 시도를 한 네트워크 

## 이더리움 백서의 제목 (차세대 스마트 컨트랙트와 탈중앙화된 어플리케이션 플렛폼)

> A(돈 송금) => B = 그다음은?? (비트코인 네트워크) => 간단한 스크립팅만 가능하다. (플렛폼을 비트코인으로 구현한다. 다중 서명 처리)
> A(돈 송금) => B = b는 A에게 보상을 준다. 서명처리는 EVM 가상 머신과 이더리움 네트워크에서 제공해준다. => 플렛폼을 개발할 수 있는 환경을 제공한다.

> 이더리움은 플렛폼에 포커스가 맞춰져 있고, 비트코인은 화폐에 포커스가 맞춰져 있다. 

> 이더리움 네트워크의 제안은 탈중앙화된 어플리케이션을 만들어라 

### 상태변환 시스템
> 이더리움 백서에서 비트코인의 트랜잭션을 `상태 변환 시스템` 
> 비트코인은 트랜잭션에서 출력값이 UTXO 라는 객체에 저장을 했는데, 
> 이더리움은 트랜잭션을 상태처리 => 우리가 배운 내용에서는 추상적으로 리액트 상태라고 봐도 무방하다.
> 간단하게 상태를 설명하면

### 쇼핑몰의 상품 구매 상태

- 상품 구매 프로세스 
- 상품의 구매 상태를 표현하는 테이블이 하나 있다.

> 상태라는 용어
**1. 주문 접수 -> 2. 결제 확인 -> 3. 상품 준비 -> 4. 상품 발송 상태 -> 5. 상품을 수령 5. 배송완료**

> UTXO -> Transaction -> UTXO 
> 잔액을 확인하고 지갑주소의 잔액을 표현하는 값을 잔액객체로 저장
> 새로운 거래를 생성해서 트랜잭션 처리가 되면 새로운 UTXO를 만들어 주었다. EOA
> UIXO라는 용어를 사용하지 않고 어카운트라는 표현을 사용한다.
> 비트코인에서 UTXO의 변경은 이더리움 네트워크에서 표현을 바꿔서 상태가 변화되었다.

#### 비트코인의 스크립팅
> 비트코인은 정말 낮은 수준의 컨트랙트와 유사한게 있었고
> 비탈릭 부테린은 서명에 관련된 로직을 스마트 컨트랙트라는 시점으로 바라보고 있다. (다중 서명 로직을 처리할 수 있는 형태를 제공하면 어떨까)
> 비트코인의 TUXO는 공개키 만으로 해당 계정의 잔액을 조회할 수 있는데
> 단순 스택 기반의 프로그래밍 언어로 표현되어있다.
> 비트코인은 2,3개 이상의 개인키를 가지고 서명을 만들어서 검증할 수 있는 간단한 스크립팅을 작성해야 플랫폼을 구현할 수 있다.(구상하기 어렵고 실용성이 많이 떨어진다)
> 그래서 이더리움은 이 내용을 스마트 컨트랙트의 개념으로 바라보고 제안했다.

#### 이더리움 네트워크
> 이더리움은 짧게 문자로 서술했을떄
> 이더리움의 목적은 분산 어플리케이션 제작을 위한 대체 프로토콜 

탈중앙 디앱을 생성하는 이유

1. bitcoin을 가지고 예금, 보험 및 금융 상품에 대한 것을 구현할 수가 없다. (이자를 구현 x)
2. 사이트 및 게임에 적용하기 힘든 부분을 구현할 수 없다.(상품 및 게임 아이템 매칭 x)
> 비트코인은 만든다고 가정하면 결제에 포커스가 맞 춰져 있기 때문에 결제에 대한 부분만을 처리한다.
> 이자의 부분만 따로 보완을 해서 처리를 하는 방향이 맞다
> 이더리움의 목적은 이러한 형태를 구현할 수 있는 플렛폼을 만든 것.
> 적은 시간을 들여서 탈중앙 앱을 Dapp을 만드는데 탈중앙 데이터를 저장할 수 있는 사이트를 쉽게 개발할 수 있다.
> 탈중앙 통신을 할 수 있는 프로토콜을 쉽게 유저가 사용할 수 있도록 구현 가능하다. 
> 탈중앙 데이터를 저장 할 수 있다. => 스마트 컨트랙트
> UTXO의 형식적인 화폐의 데이터가 아닌 상태 즉 상태의 변화를 만들어서 다양한 데이터를 저장하고 사용할 수 있도록 트랜잭션의 구조가 완전히 바뀐 것

#### 이더리움 (UTXO의 변화)
> 이더리움에서는 상태(state)는 account라는 객체로 구성되어있다.
> account 

```ts
interface Account {
    nonce : number; // 블록의 논스가 아니고 (계정이 발생시킨 트랜잭션의 횟수, 이중지불의 방지용으로 사용되는 값)
    balance : string; // 이더(잔액)
    storageRoot : string; // account의 상태를 저장하고 있는 공간(머틀 패트리샤) 상태의 검증
    codeHash : string; // 스마트 컨트랙트 계약의 코드 스마트 컨트랙트 배포를 하면 컨트랙트로 작성한 코드의 내용이 바이트 코드로 변환되어서 저장된다. 블록에 기록이 되고, 변조가 불가능하다.(프록시 패턴을 사용해서 )
}
```
> 이더라는 이더리움 플렛폼의 화폐단위가 있고,
> 트랜잭션을 발생 시킬때 수수료로 지불 하는데 사용
> 코드 해시에 있는 메서드를 호출해서 스토리지 루트의 상태를 변환할 때 이더라는 화폐를 지불해서 상태를 변화할 수 있게 설계했다.

### 이더리움 네트워크의 튜링 완전(엘런 튜링)
> 컨트랙트로 작성해서 저장된 바이트 코드가 실행되는 런타임 환경
> EVM이 없으면 컨트랙트를 호출할 수 없다.
> 튜링 완전 기계 : 조건문 반복문 등등의 모든 계산은 가능한 계산이다. 가스비
> EVM의 구조와 동작 원리는
> 256비트의 워드 크기를 사용하는 스택 메모리 저장소 

> 스택 : 임시 저장 데이터 연산 처리할때 스마트 컨트랙트 실행중
> 메모리 : 임시 저장 공간 휘발성. 함수 실행중에 할당하는 중간 데이터
> 저장소 : 영구 데이터 저장소. 상태가 변화하면 여기에 영구 저장된다. 스마트 컨트랙트의 상태 저장

> 스마트 컨트랙트는 실행이 되어야 실행될 수 있는 형태의 코드를 제공한다. 
> 스마트 컨트랙트의 코드는 바이트 코드의 형태로 실행을 한다.
> opcode를 사용할때 => 140개 가량 많은 명령어 하나에 바이트가 1바이트

```js
ADD 두값을 더한다. => 3GAS
```

#### 스마트 컨트랙트의 흐름
1. 트랜잭션을 블록에 포함하고 EVM에서 실행 트리거(상태를 업데이트)
2. 트랜잭션의 data 필드에 호출 대상으로 지정된 컨트랙트의 함수와 매개변수를 해석해서
3. EVM은 명령어를 하나씩 해석해서 스택과 메모리를 사용해서 계산 연산 수행
4. 저장소에 상태 저장을 한다. 상태 저장이 완료되면 블록체인 변화가 된거고 전파
5. 실행이 완료되면 결과에 따른 GAS가 소모된다. 

#### EVM (Ethereum Virtual Machine) (이더리움 네트워크의 가장 큰 특징)
- 스마트 컨트랙트는 EVM에서 완벽하게 내부 구조에 위험성은 배제하고 격리 시켜서 실행을 한다. 시스템에 직접 접근 불가능하게 구성했다. (격리성)
- 결정성 : 모든 노드의 동일한 결과를 내도록 보장하는 합의를 설계했다.
- 가스의 매커니즘 : 무한루프 코드나 공격성있는 코드의 방지를 위해서 계산이 가능한 코드를 계산량에 따라 수수료 비용을 부과했다.
- 스마트 컨트랙트 배포 : 생성 트랜잭션을 바이트 코드로 저장소에 저장한다.
> 노드에 포함되어 있는 것 => 풀노드(EVM), 라이트 노드(EVM X)

### 이더리움 어카운트
> 이더리움에는 상태와 account라고 하는 객체로 구성되어있다.

```js
interface Account {
    nonce : number;
    balance : string;
    storageRoot : string; // X 상태의 값이 사용자의 계정에?
    codeHash : string; // X 상태의 값이 사용자의 계정에?
}
```

> 이더리움의 어카운트는 2가지의 형태가 있다.
> 노드에 포함되어있는 것.
> EOA가 있고, 이 계정은 사용자가 사용하는 계정
> CA가 있다. 컨트랙트의 주소

##### CA
```js
interface Account {
    nonce : number;
    balance : string; // 이더리움 창고
    storageRoot : string; // 유저의 주문 상태 (변조 불가)
    codeHash : string;
}
```
> 컨트랙트의 주소에 있는 계정은 모든 값을 사용한다. EOA에서는 nonce랑 balance만 사용된다. 
> 컨트랙트 코드를 우리가 만들고 빌드 => ABI, Byte 코드를 네트워크로 요청
> 내가 배포한 컨트랙트 저장 => CA(해시문자열) => setCount() 이거 실행하고 싶어 (CA)

#### EOA(Externally Owned Account), CA (Contract Account)
#### EOA (외부 소유 계정)
- 사용자 지갑
- 개인키를 가지고 있어 트랜잭션에 서명하고 발생시킬 수 있다.
- nonce와 balance를 가지고 있다.
    - nonce : 계정이 발생시킨 트랜잭션의 횟수
    - balance : 이더잔액

#### CA (컨트랙트 계정)
- 블록체인에 배포된 스마트 컨트랙트의 주소
- 개인키가 없으므로 직접 트랜잭션을 발생시킬 수 없다. 대신 EOA로부터 트랜잭션을 받아 스마트 컨트랙트 내부의 로직을 실행하는 메시지 호출을 한다.
- storageRoot와 codeHash 를 가진다
    - storageRoot : 컨트랙트의 상태 데이터를 저장하는 공간 (쇼핑몰의 '주문 상태 테이블'처럼, 컨트랙트의 특정 상태 값을 영구적으로 저장하고 검증하는 공간. 예를 들어, 사용자의 주문 상태(상품 준비 중, 배송 완료 등)가 여기에 기록되어 변조 불가능한 데이터가 된다.)
    - codeHash : 배포된 스마트 컨트랙트의 바이트 코드 해시 (스마트 컨트랙트 코드가 바이트 코드로 변환되어 블록체인에 기록된 해시값)

#### 메세지와 트랜잭션
> 이더리움에서 서명이 없는 영수증 즉 트랜잭션은 서명이 있는 영수증
> 서명이 없는 영수증인 메세지라고 한다.
> 서명의 유무는 개인키의 유무와 직결된다. 

> EOA 계정이 트랜잭션을 발생 시킬수 있는 이유
> CA는 트랜잭션을 발생 시킬수 없다 Message를 발생 시킬수 있다. 

```js
// 메세지
interface Message {
    from : string; // 보내는 계정
    to : string; // 받는 계정
    gas : number; // 메세지를 처리하기 위한 가스의 량
    gasPrice : number; // 가스당의 가격 
    value : number; // 트랜잭션을 전달할때 계정에 전달할 이더량
    data : string; // 메세지 데이터
    nonce : number; // 메세지를 전송한 트랜잭션 몇번 메세지 몇번 횟수
}   
// 가스의 가격이 정해지는 때 처리가 될때 (네트워크 복잡도 + 가스당 가격 + 내 코드의 가스 가격)
// 트랜잭션은 메세지를 포함하고 있다. 라고 객체의 구조를 정의했을때
// 저장소의 값을 변경한다 라는것은 튜링 완전의 머신을 계산이 되어야하는 머신 가스비
// 네트워크 자원을 쓴다 한정적인 연료
interface Transaction extends Message {
    v : number;
    r : string;
    s : string;
}
```

#### 이더리움 GAS 
> EVM 상에서 트랜잭션을 처리하기 위해서 소모되는 자원
> 코드의 복잡성에 따라서 측정이 되기 때문에 가스량은 요청하기 전까지 알수 없다.
> (네트워크 복잡도 + 가스당 가격 + 내 코드의 가스 가격)
> GAS의 가격은 거래가 걸리는 시간에도 영향을 준다. => 가스비가 비싸면 더 빠르게 처리된다. (가속화)
> 사용자가 GAS당의 가격을 설정해서 수수료를 조정해서 더 빠르게 처리할수 있다.
> 이더의 화폐 단위가 나눠져있는데 나눠진 궁극적인 목표는 수수료의 단위를 계산하기 위해서 1000원짜리, 500원짜리 100원짜리 
> GAS의 계산을 하기 위한 단위는 Gwei 1ETH = 1.000.000.000Gwei 가스를 계산하기 위한 단위
> 기본 가스당 금액은 21,000 * 100
> byte당 대략 5GAS로 측정한다. 