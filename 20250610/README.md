# 타입 어서션, 타입 엘리어스, 타입 클래스 수정자, 전략패턴


## 타입 어서션
> 타입의 추론을 알려준다.
> document.querySelecter(".app") as "타입"

```ts
const input = document.querySeletor("input") as HTMLinputElemnt
```
> 타입 어서션은 구체적인 객체의 타입을 알려준다.

```sh
npm i -g typescript
npx tsc --init
npx tsc # 설정 파일을 읽어서 컴파일 진행
```

### 타입 엘리어스
> 타입 지정에 별명을 붙여준다.
> 유저의 회원가입 데이터의 구조를 별명을 붙인다.
> interface는 기능이다 사물의 객체의 구조를 정의할때
> type은 DTO 등 전달하는 데이터의 형태를 정의할사용한다.

> 전달하는 데이터 타입의 형태는 type을 사용하고 인스턴스 생성에 간에서는 class를 권장한다.
```ts
type UserLogin = {
    uid : string,
    upw : string
} 
```
> ts-node : 메모리상에 컴파일된 내용을 가지고 노드 런타임환경에서 실행시킨다. 파일 생성은 X

### class
> 객체지향 프로그래밍
> 객체의 프로퍼티를 어디서든 참조를 하게 하는것은 막는다
```ts
class User {
    private name : string; // 생성한 인스턴스의 name은 표기법으로 접근이 불가능하게 막는다. 직접참조를 할수 없게 만든다. 의도치않게 속성의 값이 변경되는것을 방지 인스턴스의 내부적인 메서드로 조회나 수정을 하게한다.

    public age : number;
    
    // 
    getName() {

    }

    setName (name : string) {

    }
}
```

## 전략패턴
> 객체지향 프로그래밍의 기본 패턴중 하나
> 기능의 구분을 명확하게 나눠서 작성하는것이 목표
> 로그인 -> 카카오, 구글, 네이버(메서드 조건문 처리)
> 기능의 구분 하나의 인스턴스는 각각의 로직의 책임을 나눠서 담당하고있고
> 새로운 로직이 추가될경우 인스턴스에 주입해서 사용한다. **(의존성 주입) IOC

```js
// 이미 작성되어 있는 기능을 수정하는 일이 번번히 발생하는 문제를
login (loginType) {
    if("kakao" == loginType) {
            // 카카오 로그인 로직
    } else if("google" == loginType) {
        // 구글 로그인 로직
    } else if("naver" == loginType) {
        // 네이버 로그인 로직
    } else if ("local" == )
}

// 카카오 로그인의 책임
const kakao = {
    login : () => {
        // 카카오 로그인 로직
    }
}
// 구글 로그인의 책임
const google = {
    login : () => {
        // 카카오 로그인 로직
    }
}
// 네이버 로그인 책임
const naver = {
    login : () => {
        // 카카오 로그인 로직
    }
}

// 로컬 로그인
const local = {
    login : () => {
        // 로직
    }
}

// 의존성 주입
// 어떤 로그인을 호출할지의 로직
const authLogin = {
    auths : {kakao, google, naver}
    login : (loginType) => {
        auths[loginType].login();
    }
    setAuth (loginObj, loginType) {
        auths[loginType] = loginObj
    }
}
setAuth(local, "local");
```

### 상품 구매 기능 요청받았다.
> 인스턴스 하나가 상품이 되고
> 상품에는 정해진 객체의 형태가 있다 
> 정해진 객체의 형태에는 각 프로퍼티마다 타입이 지정되어있다.

1. 할인의 구조를 정의할 인터페이스(할일 할수 있는 기능을 가지고 있는 형태)
2. 고정된 가격을 할인하는 기능을 담당하는 인스턴스
3. 퍼센트 가격을 할인하는 기능을 담당하는 인스턴스
4. 상품의 구조를 정의하는 인스턴스
5. 할인의 기능과 상품의 인스턴스를 전달받아서 할인의 기능을 담당하는 인스턴스

### 블록체인 비트코인 core 타입스크립트 구현
> 비트코인 block => 데이터를 저장하는 영역(데이터를 위변조 할수 없는 설계)
> p2p 방식을 기반으로 생성한 체인의 형태를 가지고 분산 데이터를 저장해서 서로간의 누구나 임의로 수정할수없고 변경의 결과를 조회할수 있는 분산 저장 컴퓨팅 기술

## 블록
> 다수의 트랜젝션(거래 이력)을 하나로 관리하기위해 사용하는 객체
> 소규모 데이터는 트랜잭션과 블록의 내용에 포함된다.
> 트랜잭션은 단순하게 거래 이력과 잔액의 내용을 관리한다.

### 블록의 구성
> 우리의 이해를 돕기위해서 객체로 생각을 하면 편하고 해더와 바디 영역을 구분해놓고 설명을 한다.
> 헤더 내용에는 블록의 정보 블록의 해시 등등의 블록에 기록되는 데이터의 설명 메타데이터
> 바디의 내용에는 블록에 저장되는 거래이력 즉 트랜잭션

### 블록의 헤더
- 버전 정보
- 이전 블록 해시 => 블록 체인의 특징 블록이 체인의 형태로 연계될수 있는 값
- 블록 높이 => 블록 인덱스 몇번재로 생성된 블록인지 번호
- 타임스템프 => 블록 생성 시간
- 해시 => 블록의 안에 모든 내용을 더해서 해시화 시킨 값
- 난이도 => 블록을 채굴할때 POW 작업증명 컴퓨팅 자원을 사용해서 알고리즘을 돌리는데 정답은 난이도에 따라 결정이 된다 2 => 0이 2개 이상의 값을 구해야한다. 0이 많을수록 시간이 오래걸린다. 블록의 생성시간을 난이도로 조정 목표시간은 10분으로 2016개의 블록마다마다 
- 논스 => POW 작업증명 방식으로 마이닝을 할때 알고리즘 즉 퀴즈를 몇번 풀었는지 컴퓨팅 자원을 사용해서 몇번이나 시도했는지 횟수
- 머클루트 => 트랜잭션의 내용 

### 블록의 바디
- 트랜잭션의 내용들 => 거래 내용들 거래의 갯수는 한정되어있고 갯수보다 바이트 하나의 블록에 담을수 있는 데이터의 량에 따라서 거래는 다음번 블록에 포함될수 있다.

### 마이닝 방식

### POW (proof of work)
> 비트코인 연산 작업 기반의 합의 알고리즘 (최초의 합의 알고리즘)
> 새로운 블록을 블록체인 네트워크에 추가하려면 난이도에 맞는 값을 찾는 컴퓨팅 연산 즉 계산을 반복해서 정답에 맞는 결과를 구하면 생성 권한을 얻는다.
> 높은 에너지 소모 환경 

### POS (proof of stake)
> 돈을 가지고 있으면 예치를 하고 있으면 지분을 가지고있으면 생태걔에 기여를 하고 있는 노드들에게 토큰을 가지고있는 량에 비례해서 퍼센트를 정해서 확율적으로 채굴 권한을 얻는다.
> 비잔틴 결함의 이론적인 위헙은 없게 구성을 하는 목적을 가지고
> 팀을 구성해서 네트워크를 방해는 경우
> 환경 친화적 전력 소비를 줄일수 있다.
> 이더리움 네트워크 기준으로 32이더 이상 가지고있을때 에포크의 시간이 지나면

### POA (proof of Athority) 
> 기업에서 많이 사용을 하는 증명 방식으로 기관에서 사용을 많이한다 노드의 채굴 증명은 네트워크에 참여한 노드들에서 허가받은 노드만 채굴권한을 가지고 있다.(두나무 블록체인 서비스 DBS 권위증명 방식)

### 블록체인의 거래 정보 변경이 불가능한 이유
> 블록의 해시가 포함되기 때문에 하나의 거래내용이 변경되면 머클루트의 값이 변경되고 블록의 해시내용이 변경되고 이전 블록과 체인이 끈기기 때문에 위변조가 불가능하다. 이후에 생성되는 블록을 따라잡을수 없다.
